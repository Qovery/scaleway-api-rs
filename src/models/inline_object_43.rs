/*
 * Instance API
 *
 * # Introduction  ## Endpoints  Scaleway instance API can be reach on  - `https://api.scaleway.com/instance/v1/zones/fr-par-1` - `https://api.scaleway.com/instance/v1/zones/fr-par-2` - `https://api.scaleway.com/instance/v1/zones/nl-ams-1` - `https://api.scaleway.com/instance/v1/zones/pl-waw-1`  Older endpoints are still reachable but should not be used for new projects  - `https://cp-par1.scaleway.com` - `https://cp-ams1.scaleway.com`  <Example>  The following code is an example request to retrieve detailed information about a volume:  ``` % curl -H 'X-Auth-Token: xxxxxxxx-xxxx-xxxxx-xxxx-xxxxxxxxxxxxx' -H 'Content-Type: application/json' https://api.scaleway.com/instance/v1/zones/fr-par-1/volumes/f929fe39-63f8-4be8-a80e-1e9c8ae22a76 -i  HTTP/1.1 200 OK Server: nginx Date: Thu, 22 May 2014 07:55:00 GMT Content-Type: application/json Content-Length: 1345 Connection: keep-alive Strict-Transport-Security: max-age=86400  {   \"volumes\": [     {       \"export_uri\": null,       \"id\": \"f929fe39-63f8-4be8-a80e-1e9c8ae22a76\",       \"name\": \"volume-0-1\",       \"organization\": \"000a115d-2852-4b0a-9ce8-47f1134ba95a\",       \"server\": null,       \"size\": 10000000000,       \"volume_type\": \"l_ssd\"     },     {       \"export_uri\": null,       \"id\": \"0facb6b5-b117-441a-81c1-f28b1d723779\",       \"name\": \"volume-0-2\",       \"organization\": \"000a115d-2852-4b0a-9ce8-47f1134ba95a\",       \"server\": null,       \"size\": 20000000000,       \"volume_type\": \"l_ssd\"     }   ] } ```  </Example>  ## Pagination  Most of listing requests receive a paginated response.  **Paginated request**  Requests against paginated endpoints accept two `query` arguments:  - `page`, a positive integer to choose the page to return. - `per_page`, an positive integer lower or equal to 100 to select the number of   items to return. The default value is `50`.  Paginated endpoints usually also accept filters to search and sort results. These filters are documented along each endpoint documentation.  **Paginated response**  ```bash % curl -H 'X-Auth-Token: <token>' 'https://api.scaleway.com/instance/v1/zones/fr-par-1/images/?page=2&per_page=10' -i HTTP/1.0 200 OK [...] X-Total-Count: 209 [...] ```  The `X-Total-Count` header contains the total number of items for the resource. 
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct InlineObject43 {
    /// Resource name
    #[serde(rename = "name")]
    pub name: String,
    /// Backend protocol. TCP or HTTP
    #[serde(rename = "forward_protocol")]
    pub forward_protocol: ForwardProtocol,
    /// User sessions will be forwarded to this port of backend servers
    #[serde(rename = "forward_port")]
    pub forward_port: f32,
    /// Load balancing algorithm
    #[serde(rename = "forward_port_algorithm")]
    pub forward_port_algorithm: ForwardPortAlgorithm,
    /// Enables cookie-based session persistence
    #[serde(rename = "sticky_sessions")]
    pub sticky_sessions: StickySessions,
    /// Cookie name for for sticky sessions
    #[serde(rename = "sticky_sessions_cookie_name", skip_serializing_if = "Option::is_none")]
    pub sticky_sessions_cookie_name: Option<String>,
    #[serde(rename = "health_check")]
    pub health_check: Box<crate::models::LbV1RegionsRegionLbsLbIdBackendsHealthCheck>,
    /// Backend server IP addresses list (IPv4 or IPv6)
    #[serde(rename = "server_ip")]
    pub server_ip: Vec<String>,
    /// Deprecated in favor of proxy_protocol field !
    #[serde(rename = "send_proxy_v2", skip_serializing_if = "Option::is_none")]
    pub send_proxy_v2: Option<bool>,
    /// Maximum server connection inactivity time (in milliseconds)
    #[serde(rename = "timeout_server", skip_serializing_if = "Option::is_none")]
    pub timeout_server: Option<f32>,
    /// Maximum initical server connection establishment time (in milliseconds)
    #[serde(rename = "timeout_connect", skip_serializing_if = "Option::is_none")]
    pub timeout_connect: Option<f32>,
    /// Maximum tunnel inactivity time (in milliseconds)
    #[serde(rename = "timeout_tunnel", skip_serializing_if = "Option::is_none")]
    pub timeout_tunnel: Option<f32>,
    /// Modify what occurs when a backend server is marked down
    #[serde(rename = "on_marked_down_action", skip_serializing_if = "Option::is_none")]
    pub on_marked_down_action: Option<OnMarkedDownAction>,
    /// The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.  * `proxy_protocol_none` Disable proxy protocol. * `proxy_protocol_v1` Version one (text format). * `proxy_protocol_v2` Version two (binary format). * `proxy_protocol_v2_ssl` Version two with SSL connection. * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information. 
    #[serde(rename = "proxy_protocol", skip_serializing_if = "Option::is_none")]
    pub proxy_protocol: Option<ProxyProtocol>,
}

impl InlineObject43 {
    pub fn new(name: String, forward_protocol: ForwardProtocol, forward_port: f32, forward_port_algorithm: ForwardPortAlgorithm, sticky_sessions: StickySessions, health_check: crate::models::LbV1RegionsRegionLbsLbIdBackendsHealthCheck, server_ip: Vec<String>) -> InlineObject43 {
        InlineObject43 {
            name,
            forward_protocol,
            forward_port,
            forward_port_algorithm,
            sticky_sessions,
            sticky_sessions_cookie_name: None,
            health_check: Box::new(health_check),
            server_ip,
            send_proxy_v2: None,
            timeout_server: None,
            timeout_connect: None,
            timeout_tunnel: None,
            on_marked_down_action: None,
            proxy_protocol: None,
        }
    }
}

/// Backend protocol. TCP or HTTP
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ForwardProtocol {
    #[serde(rename = "tcp")]
    Tcp,
    #[serde(rename = "http")]
    Http,
}
/// Load balancing algorithm
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ForwardPortAlgorithm {
    #[serde(rename = "roundrobin")]
    Roundrobin,
    #[serde(rename = "leastconn")]
    Leastconn,
    #[serde(rename = "first")]
    First,
}
/// Enables cookie-based session persistence
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StickySessions {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "cookie")]
    Cookie,
    #[serde(rename = "table")]
    Table,
}
/// Modify what occurs when a backend server is marked down
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum OnMarkedDownAction {
    #[serde(rename = "on_marked_down_action_none")]
    OnMarkedDownActionNone,
    #[serde(rename = "shutdown_sessions")]
    ShutdownSessions,
}
/// The PROXY protocol informs the other end about the incoming connection, so that it can know the client's address or the public address it accessed to, whatever the upper layer protocol.  * `proxy_protocol_none` Disable proxy protocol. * `proxy_protocol_v1` Version one (text format). * `proxy_protocol_v2` Version two (binary format). * `proxy_protocol_v2_ssl` Version two with SSL connection. * `proxy_protocol_v2_ssl_cn` Version two with SSL connection and common name information. 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ProxyProtocol {
    #[serde(rename = "proxy_protocol_unknown")]
    Unknown,
    #[serde(rename = "proxy_protocol_none")]
    None,
    #[serde(rename = "proxy_protocol_v1")]
    V1,
    #[serde(rename = "proxy_protocol_v2")]
    V2,
    #[serde(rename = "proxy_protocol_v2_ssl")]
    V2Ssl,
    #[serde(rename = "proxy_protocol_v2_ssl_cn")]
    V2SslCn,
}

